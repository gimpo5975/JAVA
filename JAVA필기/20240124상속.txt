1. 클래스의 상속
  1) 상속(inheritance) : 
      부모 클래스의 멤버(필드, 메소드, 이너클래스)를 물려 받아 자식 클래스 내부에 포함시키는 것
      생성자는 상속 되지 않음
      private 접근제한자를 가진 멤버는 상속되지 않음
      final 이 붙은 클래스는 상속되지 않음(String 클래스)
   
  ※final 클래스를 사용하는 목적 : 상속할 수 없고, 자식클래스를 정의해 놓고 비공개 정보에 접근하거나 시스템을 파괴하는 경우를 방지하기 위한 것
  ※상속의 장점 : 코드의 중복성을 제거, 클래스의 다형적 표현이 가능

  2) 다형성(polymorphism) : 
      1개의 객체를 여러 가지 모양으로 표현할 수 있는 특성
      자식인 내 타입으로도 객체를 담을 수 있고, 부모와 조상의 타입으로 자식의 객체를 담을 수 있는 것 ( 부모 것은 내것, 내것도 내것)
      public class Dog extends Animal{ }
        Dog dog = new Dog();
        Animal animal = new Dog();
        Dog dog =(Dog)animal;
        Object do = new Dog();

  3) 자바는 다중 상속이 불가능
      class 자식_클래스명 extends 부모_클래스명 {  }

  4) jvm은 자식 클래스의 객체를 생성할 때 먼저 부모 클래스의 객체를 생성한 후 자식 객체를 완성
     -> 자식 클래스에서 추가한 필드와 메소드를 객체에 추가

2. 객체의 타입 변환
  1) 업캐스팅(up casting):
	범위가 좁은 쪽에서 넓은 쪽으로 캐스팅하는 것
        자식 클래스에서 부모 클래스 쪽으로 변환되는 것
        자식 클래스는 항상 업캐스팅할 수 있으므로 명시적으로 적어 주지 않아도 컴파일러가 대신 넣어 줌

  2) 다운 캐스팅 : 
	업캐스팅의 반대
        다운 캐스팅은 개발자가 직접 넣어 주어야 함
        예외 - ClassCastException( 부모를 자식으로 다운캐스팅 문법적으로 오류 아니나 실행 이후 실제 캐스팅 과정에서 예외 발생)
   	
   	public class Dog extends Animal{ }
   	Dog dog = new Dog();
    	Animal animal = new Dog();  // 업캐스팅
   	Dog dog =(Dog)animal; // 다운캐스팅
   	Object do = new Dog();  // 업캐스팅

  3) 캐스팅 가능 여부는 무슨 타입으로 선언돼 있는지는 중요하지 않음, 
      다만 어떤 생성자로 생성됐는지가 중요
      선언된 타입이 의미하는 것은 실제 객체에서 자신이 선언된 타입의 
      객체를 가리키게 되는 것
      다운 캐스팅을 하기 위해서는 힙 메모리 내에 해당 객체가 있어야 함

    4) 캐스팅 가능 영부 확인 : instanceof키워드
           참조변수 instanceof 타입  
		타입 참조변수 = new 타입();
          // true - 참조변수가 해당 타입으로 캐스팅 가능, 
          // false -  참조변수가 해당 타입으로 캐스팅 불가능
	
	jdk12버전 이후
		참조변수 instanceof 타입 참조변수

    5) 메소드 오버라이딩(overriding) : 부모 클래스에서 상속받은 메소드와 
       동일한 이름의 메소드를 재정의하는 것(자식에 맞게 고쳐서 사용하는 것)
       . 부모 클래스의 메소드와 시그너처 및 리턴 타입이 동일해야 함
       . 부모 클래스의 메소드보다 접근 지정자의 범위가 같거나 넓어야 함

   . 주의) 인스턴스 필드와 정적멤버(정적필드, 정적메소드)는 
                자식 클래스에서 동일한 이름으로 정의해도 오버라이딩 되지 않는다.
               . 인스턴스는 필드는 객체 내에 존재하므로 저장 공간이 완전히 
                  분리되어 있어 오버라이딩 되지 않음
               . 정적(static) 필드와 정적 메소드는 클래스 내부에 존재하므로 
                  저장 공간이 완전히 분리되어 있음. 오버라이딩 되지 않음

    . 인스턴스 메소드는 객체 내의 메소드 위치를 저장하는 공간은 
                  분리 되어 있지만 실제 메소드가 저장되는 공간은
                  인스턴스 메소드 영역 한곳이므로 오버라이딩이 발생함

               . 동일한 필드나 동일한 메소드가 있을 때 참조 변수가 가리키는 
                 객체의 바깥쪽부터 안쪽으로 들어가면서 만나는 첫 번째 멤버가 실행

   . final이 붙은 메소드는 오버라이딩을 할 수 없음
     final 메소드는 자식에서 변경되면 안되는 메소드 사용

   . @ - 어노테이션 : 컴파일러가 문법 오류를 미리 정검하게 하거나 실행 시간
      도중에 특정 기능을 수행하도록 정보를 제공
     @Override  -> 컴파일러에게 뒤에 있는 메소드를 미리 정검하게 함

3. super 키워드와 super()메소드
   1) super : 부모의 객체
   super.부모필드명
   super.부모메소드명()
      this : 자신의 객체(자신이 가리키 객체 주소)
   this.필드명   

    2) super() : 부모의 생성자
   반드시 생성자의 첫 줄에 위치, 만일 생략하면 컴파일러가 자동 삽입
   생략되면 기본적으로 컴파일러가 컴파일할 때 자동으로 삽입
   super();  // 부모의 기본생성자 호출
   super(매개값,...) ; //부모의 매개변수가 있는 생성자 호출
        // 매개변수의 타입과 개수는 매개값의 타입과 개수랑 일치해야 함

       this() : 자신의 생성자
   this();  //기본 생성자 호출
   this(매개값,...) // 매개변수가 있는 생성자 호출
        // 매개변수의 타입과 개수는 매개값의 타입과 개수랑 일치해야 함
          반드시 생성자의 첫 줄에 위치, 만일 생략하면 컴파일러가 자동 삽입

   다른 생성자 없이 생성자가 생략되면
   컴파일러가 컴파일시 자동으로 기본 생성자를 삽입
   그러나 단 하나라도 매개값을 가진 생성자가 존재하면 
   자동으로 삽입하지 않음