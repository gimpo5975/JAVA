Vector 클래스

1) 동적 크기 조정: Vector 클래스의 주요 기능 중 하나는 동적으로 크기를 조정하는 기능입니다. 일단 생성되면 크기가 고정되는 배열과 달리 벡터는 필요에 따라 크기를 동적으로 늘리거나 줄일 수 있습니다.

2) 동기화된 작업: 'ArrayList'와 달리 'Vector'는 동기화됩니다. 이는 해당 메서드가 모두 스레드로부터 안전하다는 것을 의미합니다. 이는 데이터 불일치나 손상을 일으키지 않고 여러 스레드가 벡터를 안전하게 조작할 수 있도록 보장합니다. 그러나 이러한 동기화에는 비용이 발생하므로 단일 스레드 작업의 경우 벡터가 ArrayList보다 느려집니다.

3) 레거시 클래스: Vector 클래스는 Java의 오래된 클래스 중 하나이며 Java 초기 버전부터 사용되었습니다. 이는 Java Collections Framework보다 이전 버전이며 원래 Java API의 일부였습니다. 아직 사용 중이지만 향상된 성능과 유연성으로 인해 'ArrayList' 및 'LinkedList'와 같은 새로운 대안이 일반적으로 선호됩니다.

4) 구현: 내부적으로 Vector 클래스는 배열을 사용하여 요소를 저장합니다. 벡터의 크기를 조정해야 하는 경우 더 큰 크기의 새 배열을 만들고 이전 배열의 요소를 새 배열에 복사합니다. 이러한 크기 조정 프로세스는 특히 대형 벡터의 경우 성능 측면에서 비용이 많이 들 수 있습니다.

5) 방법 및 작업:

	◎ addElement(E obj): 벡터 끝에 요소를 추가합니다.
	◎ removeElement(Object obj): 벡터에서 지정된 요소의 첫 번째 항목을 제거합니다.
	◎ elementAt(int index): 지정된 인덱스에 있는 요소를 반환합니다.
	◎ size(): 벡터의 요소 수를 반환합니다.
	◎ capacity(): 벡터의 현재 용량(즉, 내부 배열의 크기)을 반환합니다.
	◎ isEmpty(): 벡터에 요소가 없으면 true를 반환합니다.
	◎ clear(): 벡터에서 모든 요소를 ​​제거합니다.
	◎ 그리고 벡터에 대한 일반적인 연산을 위한 더 많은 유틸리티 메서드.

6) 성능 고려 사항: Vector는 동기화를 제공하지만 이 동기화에는 성능 오버헤드가 따른다는 점에 유의하는 것이 중요합니다. 동기화가 필요하지 않은 애플리케이션의 경우 ArrayList 또는 기타 동기화되지 않은 컬렉션이 더 나은 성능을 제공할 수 있습니다.

7) 사용 사례: 성능 단점에도 불구하고 Vector는 스레드 안전이 우선시되고 애플리케이션이 공유 컬렉션에 동시에 액세스하고 수정하기 위해 여러 스레드가 필요한 시나리오에서 여전히 유용할 수 있습니다.

요약하자면, Java의 Vector 클래스는 동기화되고 동적으로 크기 조정이 가능한 배열과 같은 데이터 구조를 제공합니다. 스레드 안전성을 제공하지만 특히 단일 스레드 시나리오에서는 ArrayList와 같은 다른 컬렉션보다 성능이 떨어질 수 있습니다. 그러나 스레드 안전성이 가장 중요한 시나리오에서는 여전히 실행 가능한 옵션입니다.